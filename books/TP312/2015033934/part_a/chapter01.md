---
title       : "你不知道的 JavaScript 上卷"
---

第一部分 作用域和闭包 Scope & Closures

第一章 作用域是什么
================

几乎所有语言最基本的功能就是，能够存储变量当中的值，并在之后能够对这个值进行访问和修改。

将变量引入程序，我们会思考一系列的问题，比如这些变量存储在哪里？程序是怎样找到它们的？等。

要解决这些问题，需要有一套设计良好的规则来存储变量，并且将来很方便的获取这些变量。这套规则可称之为 **作用域** 。

## 1.1 编译原理

虽然 JavaScript 不是提前编译的，但它确实是一门编译语言。

在传统语言的处理流程中，一段代码在执行之前将经历以下三个步骤，统称为 **编译** 。

1. **分词 / 词法分析 ( Tokenizing / Lexing )**

    - 分词即将代码令牌化，此过程会将代码字符串分解成有一定意义的代码块，每个代码块成为 词法单元 ( token ) 。
    - token 的识别通常通过 有状态 或 无状态 的方式进行。
    - 若在判断一个 token 调用的是 有状态 的解析规则时，通常称为 词法分析，否则称为 分词。

2. **解析 / 语法分析 ( Parsing )**

    - 此过程会将 词法单元流（数组） 转换为一个由元素逐级嵌套组成的代表了程序语法结构的树。
    - 得到的树通常称为 抽象语法树 ( Abstract Syntax Tree, AST ) 。
    - 代码 `var a = 2;` 可能得到以下 AST ：
        - `VariableDeclaration` -- 顶级节点，包括两个子节点
            - `Identifier` -- 其值为 `a`
            - `AssignmentExpression` -- 包括一个子节点
                - `NumericLiteral` -- 其值为 `2`
    - 伪代码：

    ```js
    var code = 'var a = 2;'
    var tokens = tokenizing(code)
    var ast = parsing(tokens)
    // result ==>
    ast = {
        VariableDeclaration: {
            Identifier: 'a',
            AssignmentExpression: {
                NumericLiteral: '2'
            }
        }
    }
    ```

3. **代码生成**

    - 将 AST 转换为可执行代码的过程被称为 代码生成。
    - 也就是将代码的 AST 转化为一组机器指令，可供硬件或引擎执行。

对于 Javascript 来说，编译通常发生在代码执行前的几微秒，甚至更短的时间内。
在讨论的 作用域 背后， Javascript 引擎用尽了各种办法来保证性能最佳，
比如 JIT 可以延迟编译甚至实施重编译。

## 1.2 理解作用域

### 1.2.1 演员表

- **引擎**
    - 负责整个 Javascript 程序的编译及执行过程。

- **编译器**
    - 引擎的好友，负责语法分析及代码生成等繁琐复杂的工作。

- **作用域**
    - 引擎的另一好友，负责收集并维护所有声明变量（标识符）组成的一系列查询，
    - 并实施一套非常严格的规则，确定当前执行代码对这些标识符的访问权限。

### 1.2.2 对话

对于代码 `var a = 2;` 引擎认为有两个完全不同的声明，
一个由编译器在编译时执行，另一个则有引擎在运行时处理。

编译器会进行如下处理：

1. 遇到 `var a` 编译器会询问作用域是否已经存在一个该名称的变量在同一个作用域的集合中。
    - 如果存在，编译器会忽略该声明，继续进行编译；
    - 否则编译器会要求作用域正在当前作用域的集合中声明一个新的变量，并命名为 `a` 。

2. 接下来编译器会为引擎生成运行时所需的代码，这些代码用于处理 `a = 2` 赋值操作。
    - 引擎运行时会首先询问作用域，在当前作用域集合中是否存在一个叫作 `a` 的变量。
    - 如果存在，引擎就会使用这个变量；否则，引擎会继续查找该变量。

如果引擎最终找到了变量 `a` 就会将 `2` 赋给它。否则引擎就会抛出一个异常。

::: tip 总结
变量的赋值操作会执行两个动作：

- 首先编译器会在当前作用域中声明一个变量（前提是之前没有声明过）
- 然后在运行时，引擎会在作用域中找到该变量，若能找到就对其进行赋值。
:::

### 1.2.3 编译器有话说

引擎执行编译器编译好的代码，会在作用域的协助下进行变量的查找工作。

变量的查找分为 LHS 查询和 RHS 查询两种类型。

- LHS 查询
    - 当变量出现在赋值操作的左侧时进行 LHS 查询。
    - LHS 视图找到变量的容器本身，从而可以对其赋值。

- RHS 查询
    - 当变量出现在赋值操作的右侧时进行 RHS 查询。
    - RHS 更准确地说是 “非左侧”
    - 可以将 RHS 理解为 retrieve his source value 即取到它的原值


代码 `console.log(a);` 中对变量 `a` 的引用是一个 RHS 查询，因为这里 `a` 并没有赋予任何值。

而代码 `a = 2;` 中对 `a` 是一个 LHS 引用，因为此时并不关心 `a` 的当前值是什么，
知识想要为 `= 2` 赋值操作找到一个目标。

::: tip 笔记
这里讲的变量查询工作，类似于处理器的寻址方式。

- LHS 的作用是找到赋值目标的所在地址。（赋值操作）
- RHS 的作用是拿到赋值源头的数据值。（取值操作）
:::

### 1.2.4 引擎和作用域的对话

```js
function foo(a) {
    console.log(a); // 2
}

foo(2);
```

- 代码最后一行需要对 `foo` 进行 RHS 查询，拿到 `foo` 的值。
- 拿到 `foo` 的值，发现是一个函数，然后执行这个函数。
- 执行函数有一个隐式的传参赋值 `a = 2` 操作，此时需要对 `a` 进行一次 LHS 查询。
- 执行函数体内容，需要对关键字 `console` 进行一次 RHS 查询，拿到对应的值。
- 经查询 `console` 是一个内置对象，并拿到成员 `log` 的值，发现是一个函数。
- 执行 `log()` 函数，需要对其传参 `a` 进行一次 RHS 查询，拿到此时 `a` 的值 `2`。
- 接下来，需要对 `log()` 的第一个参数 `arg1` 进行一次 LHS 查询，将获取过来的数据 `2` 赋值给它。
- ...


## 1.3 作用域嵌套

作用域是根据名称查找变量的一套规则。

在实际使用中，通常需要同时顾及多个作用域。

当一个块或函数嵌套在另一个块或函数中时，就发生了作用域嵌套。

当在一个作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，
直到找到该变量，或抵达最外层（全局）作用域为止。

## 1.4 异常

在变量还未声明时，对于 LHS 和 RHS 查询的行为是不一样的。

```js
function foo (a) {
    console.log(a + b);
    b = a;
}

foo(2);
```

在上面示例代码中，第一次对变量 `b` 进行 RHS 查询时，无法找到该变量。

如果 RHS 查询在所有嵌套的作用域中遍寻不到所需变量，引擎就会抛出 `ReferenceError` 异常。

::: danger 错误类型
`ReferenceError` 表示引用错误，即引用了未被定义的变量。
:::

而在 LHS 查询时，若无法找到目标变量，引擎就会在全局作用域创建该名称的变量（非严格模式）。


ES5 中引入了 `'use strict';` 严格模式，在严格模式下禁止自动或隐式的创建全局变量。

在严格模式中 LHS 查询失败时，不会创建并返回一个全局变量，而会抛出与 RHS 查询失败时类似的 `ReferenceError` 异常。

:::tip 参考

- 严格模式 [Strict mode - JavaScript | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)

- 非严格模式 [Sloppy mode - MDN Web Docs Glossary | MDN](https://developer.mozilla.org/en-US/docs/Glossary/Sloppy_mode)

> Sloppy mode 也常称为 正常模式、宽松模式、懒惰模式
:::


